# 策略模式

## 动机
* 在软件构建过程中,某些类常常会用到一些算法,这种算法多种多样,编码到对象中将会非常的复杂
* 如何在运行时根据场景的需要更改的算法,如何做到算法与对象本身的解耦?

## 模板案例
某大型超市某月举行大型的线上促销活动,提供了两种折扣方式,满减和打折,公司安排小李对订单折扣进行处理,小李分析之后,给出了代码

```C#
public enum  DiscountType
{
    [Description("9折优惠")]
    Discount,

    [Description("满300减20")]
    FullAndSubtract
}

public class SalesOrder
{
    private DiscountType _discountType;
    private List<decimal> _products;
    public SalesOrder(DiscountType discountType)
    {
        _discountType = discountType;
        _products = new List<decimal>();
    }
    
    //添加一个商品,为了简单设计,只添加价格
    public void AddProduct(decimal price)
    {
        _products.Add(price);
    }
    
    public decimal CaculateCost()
    {
        decimal cost = _products.Sum();

        if(_discountType == DiscountType.Discount)
        {
            cost = cost * 0.9m;
        }

        if(_discountType == DiscountType.FullAndSubtract)
        {
            if(cost >= 300)
            {
                cost = cost - 20;
            }
            
        }
        
        return cost;
    }
}

public class Program
{
    void Main()
    {
        var salesOrder = new SalesOrder(DiscountType.Discount);
        salesOrder.AddProduct(90);
        salesOrder.AddProduct(100);
        salesOrder.AddProduct(120);

        var cost = salesOrder.CaculateCost();
        System.Console.WriteLine($"实际需要支付金额{cost}");  
    }
}
```
这次活动完美完毕,到了年底,超市搞年终大促,要出一个满金额增礼品活动,小李察觉到,这个活动的变化可能会随着时间的增加,更加的频繁,
必须要想个办法处理这种变化,不然代码糟糕的没法维护,经过一番折腾,代码如些
```C#
//抽象公共的计算金额的方式
public interface IDiscountStrategy
{
    decimal CaculateCost(IList<decimal> products);
}

//买300减20
public class FullAndSubstract : IDiscountStrategy
{
    public decimal CaculateCost(IList<decimal> products)
    {
        decimal cost = 0m;
        if(products != null)
        {   
            cost = products.Sum();
            if(cost >= 300)
            {
                cost = cost - 20;
            }
        }
        
        return cost;
    }
}

//满300送礼物
public class FullAndPresent : IDiscountStrategy
{
    public decimal CaculateCost(IList<decimal> products)
    {
        
        decimal cost = 0m;
        if(products != null)
        {   
            cost = products.Sum();
            if(cost >= 300)
            {
                //赠送30的礼品
                products.Add(30);
            }
        }
        
        return cost;
    }
}

//全场9折优惠
public class Discount : IDiscountStrategy
{
    public decimal CaculateCost(IList<decimal> products)
    {
        decimal cost = 0m;
        if(products != null)
        {   
            cost = products.Sum();
            cost = cost * 0.9m;
        }
        
        return cost;
    }
}

public class SalesOrder
{
    private readonly IDiscountStrategy _discountStrategy;
    private List<decimal> _products;

    public SalesOrder(IDiscountStrategy discountStrategy)
    {
        //后续用工厂方法处理销售策略对象,让它灵活的创建策略对象
        _discountStrategy = discountStrategy;
        _products = new List<decimal>();
    }

    public void AddProduct(decimal price)
    {
        _products.Add(price);
    }

    public decimal CaculateCost()
    {
        //创建了统一的策略方法,面向接口编程(多肽)
        return _discountStrategy.CaculateCost(_products);
    }
}

public class Program
{
    public void Main()
    {
        //根据实际情况选择了一种打折的促销方法
        SalesOrder salesOrder = new SalesOrder(new FullAndSubstract());
        salesOrder.AddProduct(95);
        salesOrder.AddProduct(115);
        salesOrder.AddProduct(100);

        var cost = salesOrder.CaculateCost();
        
        System.Console.WriteLine($"实际需要支付金额{cost}");  
    }
}
```

## 模式定义
* **定义一系列算法,把它们一个个封装起来,并且使它们可相互替换(变化),独立于客户端的应用程序(稳定)而变化(拓展,子类)**

## 总结
* Strategy及其子类为组件提供了一系列可重用的算法,从而使得类型类运行时方便算法的切换
* Strategy模式提供了条件判断意外的另外一种选择,消除条件判断语句,就是在解耦,含有多条件判断语句的代码通常需要用Strategy模式
* 如果Strategy对象没有实例变量,那么各个上下文都可以共享一个Strategy对象,从而节约对象的开销