# 模板方法模式

## 动机
* 在某些任务中,它常有稳定的整体操作结构,但是子步骤却有不同的变化
* 如果在稳定的操作下,来应对灵活的子类变化?
  
## 模板方法案例
在项目中,我们常常会遇到一个功能有多个步骤,每个步骤完成一部分的功能,所有步骤的全部执行完毕才算整个功能完成
我们先模拟一个这样的场景,来描述模板方法是如何处理的。

```C#
public class Libary
{
    public void Step1(){}
    public void Step3(){}
    public void Step5(){}
}

public class Application
{
    public bool Step2(){return true;}
    public void Step4(){}
}

public class Program
{
    static void Main()
    {
        var libary = new Libary();
        var app =  Application();
        libary.Step1();

        if(app.Step2()) 
        {
            libary.Step3();
        }

        for(var i=0;i<5;i++>)
        {
            app.Step4();
        } 
        libary.Step5();
    }
}
```
我们有两个开发者来开发整个算法
    * Libary开发者定义三个功能的步骤Step1,3,5
    * Application开发者定义了两个功能Step2,4和功能的算法主体Main
在Main的主体中,我们看到了算法的运行结构,这是一个常规的算法结构,如果步骤越来越多,那么Main中的算法就会非常的复杂
当我们使用模板模式之后
```C#
public class Libary
{
    public void Step1(){}
    
    public void Step3(){}
    
    public void Step5(){}

    protected virtual bool Step2(){ return true;}
    protected virtual void Step4(){}

    //算法的结构
    public void Run()
    {
        Step1();
        if(Step2())
        {
            Step3();
        }
        for(var i=0;i<10;i++)
        {
            Step4();
        }
        Step5();
    }
}

public class Application:Libary
{
    protected override bool Step2(){return true;}
    protected override void Step4(){}
}

public class Program
{
    static void Main()
    {
        var app = new Application();
        app.Run();
    }
}
```

我们来看一下两种方式他们之间的区别

![TemplateMethod](https://raw.githubusercontent.com/neoshero/CloudNotes/master/Images/DesignPattern/Template%20Method.svg)

## 常规方法-早绑定(应用程序开发)
* 它将程序的主要流程交给了应用程序,需要自己编写程序的流程
* Application提前知道了Libary的Api,并知道具体的功能
* 它需要Application开发者有很高的技术要求
  
## 模板方法-晚绑定(框架设计)
* Libary开发者已经定义整个功能的算法结构
* 变化的步骤交给Application开发者自己定义
* Application开发者不需要关心整个流程是如何运行的,只关心自己功能的实现

## 模板方法定义
定义一个操作算法中的骨架(稳定),将一些步骤延迟(变化)到子类中
它不改变算法的整体结构(复用),但是可以重新定义(Override)某些步骤

看到模板方法的定义是不是有一种熟悉的感觉,Asp.Net中的HttpApplication请求管道,给我们定义好的十九个管道方法,我们可以选择重构哪些管道


## 模板方法总结
* 它是一种非常基础的设计模式,在程序中大量的使用,为框架中变化的内容提供**灵活的拓展点**
* 它将流程控制的主导权由应用程序转交给了框架,反向控制流程
* 使用模板方法,一般情况下它不需要将类的Api接口公开,因为他是一个整体,无法单独存在,所以方法的作用域设置为Protected