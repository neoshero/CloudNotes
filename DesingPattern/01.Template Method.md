# 设计模式学习的精髓
* 在稳定结构与变化中,寻找他们之间的隔离点
        

# 模板方法

## 动机
* 在某些任务中,它常有**稳定的整体操作结构**,但是子步骤却有不同的变化
* 如果在稳定的操作下,来应对灵活的子类变化?
  
## 案例
某大型公司,需要开发一套完整Http请求管道处理方法,定义了一套请处理方法,分别将请求功能和授权功能交给2名开发者
最后得到代码结果如下:

```C#
//请求管道
public class HttpApplication
{
    //处理请求信息
    public void Request(){}
    //处理路由
    public void Routing(){}
    //执行方法
    public void Execute(){}
}

//自己处理请求授权和数据授权
public class CustomApplication
{
    public bool Authenticate(){}
    public void Authorize(){}
}

//Http管道整体流程
public class Program
{
    public void Main()
    {
        //整个HttpApplication管道的算法流程
        HttpApplication httpApplication = new HttpApplication();
        CustomApplication customApplication = new CustomApplication();

        httpApplication.Request();
        httpApplication.Routing();
        if(customApplication.Authenticate() && customApplication.Authorize())
        {
            httpApplication.Execute();
        }
    }
}
```
我们来看看两名开发者的工作职责
*  Application开发者定义了三个方法 Request、Routing、Excute
*  CustomApplication开发者定义了两个功能Authenticate、Authorize和负责开发程序了主流程
*  Request->Routing->只有当CustomApplication的两种验证通过,才会执行Execute

架构师看了之后,发现流程结构过于复杂,某些稳定的功能暴露出来,于是修改了两位开发者的代码

```C#
public class HttpApplication
{
    private void Request(){}
    private void Routing(){}
    private void Execute(){}

    protected virtual void Authenticate(){}
    protected virtual void Authorize(){}

    public void Main()
    {
        Request();
        Routing();
        if(Authenticate() && Authorize())
        {
            Execute();
        }
    }
}

public class CustomApplication:HttpApplication
{
    protected override bool Authenticate(){return true;}
    protected override void Authorize(){}
}

public class Program
{
    public void Main()
    {
        CustomApplication builder = new CustomApplication();
        builder.Main();
    }
}
```

我们来看一下两种方式他们之间的区别

![TemplateMethod](https://raw.githubusercontent.com/neoshero/CloudNotes/master/Images/DesignPattern/01.Template%20Method.jpg)

## 常规方法-早绑定(应用程序开发)
* 它将程序的主要流程交给了CustomApplication,需要自己编写程序的流程
* CustomApplication提前知道了HttpApplication的Api,并需要了解具体的功能
* 它需要CustomApplication开发者有很高的技术要求(流程的复杂度)
  
## 模板方法-晚绑定(框架设计)
* HttpApplication开发者已经定义整个功能的算法结构,你只需要调用我就够了
* CustomApplication开发者不需要关心整个流程是如何运行的,只关心自己功能的实现
* 变化的步骤交给CustomApplication开发者自己定义,将变化延迟到子类中

我们回过头,再看看模板方法的定义

## 模板方法定义
* 定义一个操作算法中的骨架(稳定),将一些步骤延迟(变化)到子类中
* 它不改变算法的整体结构(复用),但是可以重新定义(Override)某些步骤

回过头我们在看看Main方法,它将功能提取到父类,并定义好稳定的算法
使用虚方法将变化的部分暴露出来,交给自己自己去实现变化的部分

## 总结
* 它是一种非常基础的设计模式,在程序中大量的使用,为框架中变化的内容提供**灵活的拓展点**
* 它将流程控制的主导权由应用程序转交给了框架,反向控制流程
* 稳定的部分,一般情况下它不需要将基类的稳定的Api接口公开,所以一般设置为Private,如果需要暴露的Api也可以设置成为Protect
* 变化的部分,因为他是算法的一部分,无法单独存在,所以virtual方法的作用域设置为Protected