# 前言
<p>
    “每一个模式描述了一个在我们周围不断重复发生的问题，以及该问题的解决方案的核心。这样，你就能一次又一次地使用该方案而不必做重复劳动”。
                                                                                         ——Christopher Alexander
</p>
    
习惯养成：<font color="red">**观察每种设计模式,寻找稳定与变化的平衡(隔离点)**</font>

## "单一职责"模式

在软件设计中,如果职责划分不清晰,那么继承得到的对象,会随着需求的变化,子类极具增加,同时充斥着重复的代码,我们需要划清职责
Decorator
Bridge

---
# 装饰模式

## 动机
* "<font color="red">**过渡的使用继承来拓展对象的功能**</font>",使得拓展方法缺少了灵活性,如果拓展功能之间进行组合,那么子类将会急剧的增加
* 如何动态的实现对象功能的拓展?如何避免拓展功能带来子类的膨胀问题?
  
## 案例

某软件公司需要开发一组关于数据流的读写功能,并且要同时支持文件流、网络流、内存流的读写方式,代码如下:
```C#
public abstract class Stream
{
    public abstract void Read(int number);
    
    public abstract void Seek(int position);
    
    public abstract void Write(byte[] bytes);
}

public class FileStream : Stream
{
    public override void Read(int number){}

    public override void Seek(int position){}

    public override void Write(byte[] bytes){}
}

public class MemoryStream:Stream
{
    public override void Read(int number){}

    public override void Seek(int position){}

    public override void Write(byte[] bytes){}
}

public class NetworkStream:Stream
{
    public override void Read(int number){}

    public override void Seek(int position){}

    public override void Write(byte[] bytes){}
}

```

公司开发完成两个月后,客户反应文件数据不太安全,信息完全暴露了,需要为数据流添加加密功能,为满足客户需求,公司提供功能如下:
```C#
public class CryptoFileStream:FileStream
{
    public override void Read(int number)
    {
        //解密
        System.Console.WriteLine("文件流解密工作");
        base.Read(number);
    }

    public override void Seek(int position)
    {
        base.Seek(position);
    }

    public override void Write(byte[] bytes)
    {
        //加密
        System.Console.WriteLine("文件流加密工作");
        base.Write(bytes);
    }
}

public class CryptoMemoryStream:MemoryStream
{
    public override void Read(int number)
    {
        //解密
        System.Console.WriteLine("内存流解密工作");
        base.Read(number);
    }

    public override void Seek(int position)
    {
        base.Seek(position);
    }

    public override void Write(byte[] bytes)
    {
        //加密
        System.Console.WriteLine("内存流加密工作");
        base.Write(bytes);
    }
}

public class CryptoNetworkStream:NetworkStream
{
    public override void Read(int number)
    {
        //解密
        System.Console.WriteLine("网络流解密工作");
        base.Read(number);
    }

    public override void Seek(int position)
    {
        base.Seek(position);
    }

    public override void Write(byte[] bytes)
    {
        //加密
        System.Console.WriteLine("网络流加密工作");
        base.Write(bytes);
    }
}
```
公司开发完成六个月后,客户反应文件数据读写速度太慢了,能不能加快一下读写速度,为满足客户需求,公司提供功能如下:

```C#
public class BufferFileStream:FileStream
{
    public override void Read(int number)
    {
        //缓冲处理
        System.Console.WriteLine("文件流缓冲Read工作");
        base.Read(number);
    }

    public override void Seek(int position)
    {
        base.Seek(position);
    }

    public override void Write(byte[] bytes)
    {
        //缓冲处理
        System.Console.WriteLine("文件流缓冲Write工作");
        base.Write(bytes);
    }
}

public class BufferMemoryStream:MemoryStream
{
    public override void Read(int number)
    {
        //缓冲处理
        System.Console.WriteLine("内存流缓冲Read工作");
        base.Read(number);
    }

    public override void Seek(int position)
    {
        base.Seek(position);
    }

    public override void Write(byte[] bytes)
    {
        //缓冲处理
        System.Console.WriteLine("内存流缓冲Read工作");
        base.Write(bytes);
    }
}

```
某一天公司架构师发现工程项目文件太多,是不是有什么问题,于是对代码进行Review,通过观察发现了问题,并制成了一张图。


## 模式定义

## 总结